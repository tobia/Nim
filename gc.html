<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<!--  This file is generated by Nim. -->
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />

<meta name="viewport" content="width=device-width, initial-scale=1.0">

<!-- Favicon -->
<link rel="shortcut icon" href="data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAUAAAAF////AP///wD///8A////AP///wD///8A////AP///wD///8A////AAAAAAIAAABbAAAAlQAAAKIAAACbAAAAmwAAAKIAAACVAAAAWwAAAAL///8A////AP///wD///8A////AAAAABQAAADAAAAAYwAAAA3///8A////AP///wD///8AAAAADQAAAGMAAADAAAAAFP///wD///8A////AP///wAAAACdAAAAOv///wD///8A////AP///wD///8A////AP///wD///8AAAAAOgAAAJ3///8A////AP///wAAAAAnAAAAcP///wAAAAAoAAAASv///wD///8A////AP///wAAAABKAAAAKP///wAAAABwAAAAJ////wD///8AAAAAgQAAABwAAACIAAAAkAAAAJMAAACtAAAAFQAAABUAAACtAAAAkwAAAJAAAACIAAAAHAAAAIH///8A////AAAAAKQAAACrAAAAaP///wD///8AAAAARQAAANIAAADSAAAARf///wD///8AAAAAaAAAAKsAAACk////AAAAADMAAACcAAAAnQAAABj///8A////AP///wAAAAAYAAAAGP///wD///8A////AAAAABgAAACdAAAAnAAAADMAAAB1AAAAwwAAAP8AAADpAAAAsQAAAE4AAAAb////AP///wAAAAAbAAAATgAAALEAAADpAAAA/wAAAMMAAAB1AAAAtwAAAOkAAAD/AAAA/wAAAP8AAADvAAAA3gAAAN4AAADeAAAA3gAAAO8AAAD/AAAA/wAAAP8AAADpAAAAtwAAAGUAAAA/AAAA3wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAAD/AAAA/wAAAP8AAADfAAAAPwAAAGX///8A////AAAAAEgAAADtAAAAvwAAAL0AAADGAAAA7wAAAO8AAADGAAAAvQAAAL8AAADtAAAASP///wD///8A////AP///wD///8AAAAAO////wD///8A////AAAAAIcAAACH////AP///wD///8AAAAAO////wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A////AP///wD///8A//8AAP//AAD4HwAA7/cAAN/7AAD//wAAoYUAAJ55AACf+QAAh+EAAAAAAADAAwAA4AcAAP5/AAD//wAA//8AAA=="/>
<link rel="icon" type="image/png" sizes="32x32" href="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAA3XAAAN1wFCKJt4AAAAB3RJTUUH4QQQEwksSS9ZWwAAAk1JREFUWMPtll2ITVEUx39nn/O7Y5qR8f05wtCUUr6ZIS++8pEnkZInPImneaCQ5METNdOkeFBKUhMPRIkHKfEuUZSUlGlKPN2TrgfncpvmnntnmlEyq1Z7t89/rf9a6+y99oZxGZf/XeIq61EdtgKXgdXA0xrYAvBjOIF1AI9zvjcC74BSpndrJPkBWDScTF8Aa4E3wDlgHbASaANmVqlcCnwHvgDvgVfAJ+AikAAvgfVZwLnSVZHZaOuKoQi3ZOMi4NkYkpe1p4J7A8BpYAD49hfIy/oqG0+hLomiKP2L5L+1ubn5115S+3OAn4EnwBlgMzCjyt6ZAnQCJ4A7wOs88iRJHvw50HoujuPBoCKwHWiosy8MdfZnAdcHk8dxXFJ3VQbQlCTJvRBCGdRbD4M6uc5glpY3eAihpN5S5w12diSEcCCEcKUO4ljdr15T76ur1FDDLIQQ3qv71EdDOe3Kxj3leRXyk+pxdWnFWod6Wt2bY3de3aSuUHcPBVimHs7mK9WrmeOF6lR1o9qnzskh2ar2qm1qizpfXaPeVGdlmGN5pb09qMxz1Xb1kLqgzn1RyH7JUXW52lr5e/Kqi9qpto7V1atuUzfnARrV7jEib1T76gG2qxdGmXyiekkt1GswPTtek0aBfJp6YySGBfWg2tPQ0FAYgf1stUfdmdcjarbYJEniKIq6gY/Aw+zWHAC+p2labGpqiorFYgGYCEzN7oQdQClN07O1/EfDyGgC0ALMBdYAi4FyK+4H3gLPsxfR1zRNi+NP7nH5J+QntnXe5B5mpfQAAAAASUVORK5CYII=">

<!-- Google fonts -->
<link href='https://fonts.googleapis.com/css?family=Lato:400,600,900' rel='stylesheet' type='text/css'/>
<link href='https://fonts.googleapis.com/css?family=Source+Code+Pro:400,500,600' rel='stylesheet' type='text/css'/>

<!-- CSS -->
<title>Nim's Garbage Collector</title>
<link rel="stylesheet" type="text/css" href="nimdoc.css">

<script type="text/javascript" src="dochack.js"></script>

<script type="text/javascript">
function main() {
  var pragmaDots = document.getElementsByClassName("pragmadots");
  for (var i = 0; i < pragmaDots.length; i++) {
    pragmaDots[i].onclick = function(event) {
      // Hide tease
      event.target.parentNode.style.display = "none";
      // Show actual
      event.target.parentNode.nextElementSibling.style.display = "inline";
    }
  }

  const toggleSwitch = document.querySelector('.theme-switch input[type="checkbox"]');
  function switchTheme(e) {
      if (e.target.checked) {
          document.documentElement.setAttribute('data-theme', 'dark');
          localStorage.setItem('theme', 'dark');
      } else {
          document.documentElement.setAttribute('data-theme', 'light');
          localStorage.setItem('theme', 'light');
      }
  }

  toggleSwitch.addEventListener('change', switchTheme, false);


  if (window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches) {
    document.documentElement.setAttribute('data-theme', "dark");
    toggleSwitch.checked = true;
  } else if (window.matchMedia && window.matchMedia('(prefers-color-scheme: light)').matches) {
    document.documentElement.setAttribute('data-theme', "light");
    toggleSwitch.checked = false;
  } else {
    const currentTheme = localStorage.getItem('theme') ? localStorage.getItem('theme') : null;
    if (currentTheme) {
      document.documentElement.setAttribute('data-theme', currentTheme);

      if (currentTheme === 'dark') {
        toggleSwitch.checked = true;
      }
    }
  }
}
</script>

</head>
<body onload="main()">
<div class="document" id="documentId">
  <div class="container">
    <h1 class="title">Nim's Garbage Collector</h1>
    <table class="docinfo" frame="void" rules="none"><col class="docinfo-name" /><col class="docinfo-content" /><tbody valign="top"><tr><th class="docinfo-name">Author:</th><td> Andreas Rumpf</td></tr>
<tr><th class="docinfo-name">Version:</th><td> 1.1.1</td></tr>
</tbody></table><blockquote><p>&quot;The road to hell is paved with good intentions.&quot;</p></blockquote>

<h1 id="introduction">Introduction</h1><p>This document describes how the GC works and how to tune it for (soft) <span id="realtime-systems_1">realtime systems</span>.</p>
<p>The basic algorithm is <em>Deferred Reference Counting</em> with cycle detection. References on the stack are not counted for better performance (and easier C code generation). Cycle detection is currently done by a simple mark&amp;sweep GC that has to scan the full (thread local heap). <tt class="docutils literal"><span class="pre">--gc:v2</span></tt> replaces this with an incremental mark and sweep. That it is not production ready yet, however.</p>
<p>The GC is only triggered in a memory allocation operation. It is not triggered by some timer and does not run in a background thread.</p>
<p>To force a full collection call <tt class="docutils literal"><span class="pre">GC_fullCollect</span></tt>. Note that it is generally better to let the GC do its work and not enforce a full collection.</p>

<h1 id="cycle-collector">Cycle collector</h1><p>The cycle collector can be en-/disabled independently from the other parts of the GC with <tt class="docutils literal"><span class="pre">GC_enableMarkAndSweep</span></tt> and <tt class="docutils literal"><span class="pre">GC_disableMarkAndSweep</span></tt>.</p>

<h1 id="realtime-support">Realtime support</h1><p>To enable realtime support, the symbol <span id="userealtimegc_1">useRealtimeGC</span> needs to be defined via <tt class="docutils literal"><span class="pre">--define:useRealtimeGC</span></tt> (you can put this into your config file as well). With this switch the GC supports the following operations:</p>
<pre class="listing"><span class="Keyword">proc</span> <span class="Identifier">GC_setMaxPause</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">maxPauseInUs</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">)</span>
<span class="Keyword">proc</span> <span class="Identifier">GC_step</span><span class="Operator">*</span><span class="Punctuation">(</span><span class="Identifier">us</span><span class="Punctuation">:</span> <span class="Identifier">int</span><span class="Punctuation">,</span> <span class="Identifier">strongAdvice</span> <span class="Operator">=</span> <span class="Identifier">false</span><span class="Punctuation">,</span> <span class="Identifier">stackSize</span> <span class="Operator">=</span> <span class="Operator">-</span><span class="DecNumber">1</span><span class="Punctuation">)</span></pre><p>The unit of the parameters <tt class="docutils literal"><span class="pre">maxPauseInUs</span></tt> and <tt class="docutils literal"><span class="pre">us</span></tt> is microseconds.</p>
<p>These two procs are the two modus operandi of the realtime GC:</p>
<p>(1) GC_SetMaxPause Mode</p>
<blockquote><p>You can call <tt class="docutils literal"><span class="pre">GC_SetMaxPause</span></tt> at program startup and then each triggered GC run tries to not take longer than <tt class="docutils literal"><span class="pre">maxPause</span></tt> time. However, it is possible (and common) that the work is nevertheless not evenly distributed as each call to <tt class="docutils literal"><span class="pre">new</span></tt> can trigger the GC and thus take  <tt class="docutils literal"><span class="pre">maxPause</span></tt> time.</p></blockquote>
<p>(2) GC_step Mode</p>
<blockquote><p>This allows the GC to perform some work for up to <tt class="docutils literal"><span class="pre">us</span></tt> time. This is useful to call in a main loop to ensure the GC can do its work. To bind all GC activity to a <tt class="docutils literal"><span class="pre">GC_step</span></tt> call, deactivate the GC with <tt class="docutils literal"><span class="pre">GC_disable</span></tt> at program startup. If <tt class="docutils literal"><span class="pre">strongAdvice</span></tt> is set to <tt class="docutils literal"><span class="pre">true</span></tt>, GC will be forced to perform collection cycle. Otherwise, GC may decide not to do anything, if there is not much garbage to collect. You may also specify the current stack size via <tt class="docutils literal"><span class="pre">stackSize</span></tt> parameter. It can improve performance, when you know that there are no unique Nim references below certain point on the stack. Make sure the size you specify is greater than the potential worst case size.</p></blockquote>
<p>These procs provide a &quot;best effort&quot; realtime guarantee; in particular the cycle collector is not aware of deadlines yet. Deactivate it to get more predictable realtime behaviour. Tests show that a 2ms max pause time will be met in almost all cases on modern CPUs (with the cycle collector disabled).</p>

<h2 id="time-measurement">Time measurement</h2><p>The GC's way of measuring time uses (see <tt class="docutils literal"><span class="pre">lib/system/timers.nim</span></tt> for the implementation):</p>
<ol class="simple"><li><tt class="docutils literal"><span class="pre">QueryPerformanceCounter</span></tt> and <tt class="docutils literal"><span class="pre">QueryPerformanceFrequency</span></tt> on Windows.</li>
<li><tt class="docutils literal"><span class="pre">mach_absolute_time</span></tt> on Mac OS X.</li>
<li><tt class="docutils literal"><span class="pre">gettimeofday</span></tt> on Posix systems.</li>
</ol>
<p>As such it supports a resolution of nanoseconds internally; however the API uses microseconds for convenience.</p>
<p>Define the symbol <tt class="docutils literal"><span class="pre">reportMissedDeadlines</span></tt> to make the GC output whenever it missed a deadline. The reporting will be enhanced and supported by the API in later versions of the collector.</p>

<h2 id="tweaking-the-gc">Tweaking the GC</h2><p>The collector checks whether there is still time left for its work after every <tt class="docutils literal"><span class="pre">workPackage</span></tt>'th iteration. This is currently set to 100 which means that up to 100 objects are traversed and freed before it checks again. Thus <tt class="docutils literal"><span class="pre">workPackage</span></tt> affects the timing granularity and may need to be tweaked in highly specialized environments or for older hardware.</p>

<h2 id="keeping-track-of-memory">Keeping track of memory</h2><p>If you need to pass around memory allocated by Nim to C, you can use the procs <tt class="docutils literal"><span class="pre">GC_ref</span></tt> and <tt class="docutils literal"><span class="pre">GC_unref</span></tt> to mark objects as referenced to avoid them being freed by the GC. Other useful procs from <a class="reference external" href="system.html">system</a> you can use to keep track of memory are:</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">getTotalMem()</span></tt> Returns the amount of total memory managed by the GC.</li>
<li><tt class="docutils literal"><span class="pre">getOccupiedMem()</span></tt> Bytes reserved by the GC and used by objects.</li>
<li><tt class="docutils literal"><span class="pre">getFreeMem()</span></tt> Bytes reserved by the GC and not in use.</li>
</ul>
<p>These numbers are usually only for the running thread, not for the whole heap, with the exception of <tt class="docutils literal"><span class="pre">--gc:boehm</span></tt> and <tt class="docutils literal"><span class="pre">--gc:go</span></tt>.</p>
<p>In addition to <tt class="docutils literal"><span class="pre">GC_ref</span></tt> and <tt class="docutils literal"><span class="pre">GC_unref</span></tt> you can avoid the GC by manually allocating memory with procs like <tt class="docutils literal"><span class="pre">alloc</span></tt>, <tt class="docutils literal"><span class="pre">allocShared</span></tt>, or <tt class="docutils literal"><span class="pre">allocCStringArray</span></tt>. The GC won't try to free them, you need to call their respective <em>dealloc</em> pairs when you are done with them or they will leak.</p>

<h1 id="heap-dump">Heap dump</h1><p>The heap dump feature is still in its infancy, but it already proved useful for us, so it might be useful for you. To get a heap dump, compile with <tt class="docutils literal"><span class="pre">-d:nimTypeNames</span></tt> and call <tt class="docutils literal"><span class="pre">dumpNumberOfInstances</span></tt> at a strategic place in your program. This produces a list of used types in your program and for every type the total amount of object instances for this type as well as the total amount of bytes these instances take up. This list is currently unsorted! You need to use external shell script hacking to sort it.</p>
<p>The numbers count the number of objects in all GC heaps, they refer to all running threads, not only to the current thread. (The current thread would be the thread that calls <tt class="docutils literal"><span class="pre">dumpNumberOfInstances</span></tt>.) This might change in later versions.</p>

<h2 id="garbage-collector-options">Garbage collector options</h2><p>You can choose which garbage collector to use when compiling source code, you can pass <tt class="docutils literal"><span class="pre">--gc:</span></tt> on the compile command with the choosed garbage collector.</p>
<ul class="simple"><li><tt class="docutils literal"><span class="pre">--gc:refc</span></tt> Deferred <a class="reference external" href="https://en.wikipedia.org/wiki/Reference_counting">reference counting</a> with cycle detection, <a class="reference external" href="https://en.wikipedia.org/wiki/Heap_(programming)">thread local heap</a>, default.</li>
<li><tt class="docutils literal"><span class="pre">--gc:markAndSweep</span></tt> <a class="reference external" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Copying_vs._mark-and-sweep_vs._mark-and-don't-sweep">Mark-And-Sweep</a> based garbage collector, <a class="reference external" href="https://en.wikipedia.org/wiki/Heap_(programming)">thread local heap</a>.</li>
<li><tt class="docutils literal"><span class="pre">--gc:boehm</span></tt> <a class="reference external" href="https://en.wikipedia.org/wiki/Boehm_garbage_collector">Boehm</a> based garbage collector, <a class="reference external" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Stop-the-world_vs._incremental_vs._concurrent">stop-the-world</a>, <a class="reference external" href="https://en.wikipedia.org/wiki/Heap_(programming)">shared heap</a>.</li>
<li><tt class="docutils literal"><span class="pre">--gc:go</span></tt> Go lang like garbage collector, <a class="reference external" href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Stop-the-world_vs._incremental_vs._concurrent">stop-the-world</a>, <a class="reference external" href="https://en.wikipedia.org/wiki/Heap_(programming)">shared heap</a>.</li>
<li><tt class="docutils literal"><span class="pre">--gc:regions</span></tt> <a class="reference external" href="https://en.wikipedia.org/wiki/Memory_management#Stack_allocation">Stack</a> based garbage collector.</li>
<li><tt class="docutils literal"><span class="pre">--gc:none</span></tt> No garbage collector.</li>
</ul>
<p>The same Nim code can be compiled to use any of the garbage collectors; the Nim syntax generally will not change from one garbage collector to another. No garbage collector is used for <a class="reference external" href="backends.html#backends-the-javascript-target">JavaScript and NodeJS</a> compilation targets. <a class="reference external" href="nims.html">NimScript</a> target uses Nim VM garbage collector.</p>
<p>If you are new to Nim and just starting, the default garbage collector is balanced to fit most common use cases. </p>



    <div class="row">
      <div class="twelve-columns footer">
        <span class="nim-sprite"></span>
        <br/>
        <small style="color: var(--hint);">Made with Nim. Generated: 2020-01-11 10:31:32 UTC</small>
      </div>
    </div>
  </div>
</div>

</body>
</html>
